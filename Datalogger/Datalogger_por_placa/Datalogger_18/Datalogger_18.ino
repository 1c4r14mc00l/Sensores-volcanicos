#include <Wire.h>
#include <RTClib.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <SPI.h>
#include <SD.h>
#include <esp_sleep.h>

// Pines para el módulo MicroSD
#define SCK 36
#define MISO 35
#define MOSI 37
#define CS 5

// Pines para el RTC DS3231
#define SDA_PIN 21
#define SCL_PIN 19
#define WAKE_PIN GPIO_NUM_4  // Pin para despertar el ESP32 desde el RTC

// Pines para sensores de temperatura
#define TEMP_PIN 17

// Número de sensores
#define NUM_SENSORS 37

// Configuración de distancias
#define DISTANCE_SHORT_CM 1
#define DISTANCE_LONG_CM 5
#define TRANSITION_SENSOR 20

// Dirección fija del nodo
#define NODE_NUMBER 2

// Variables globales
RTC_DS3231 rtc;                           
OneWire oneWire(TEMP_PIN);                
DallasTemperature sensors(&oneWire);      
File dataFile;                            

//Direcciones de sensores:
DeviceAddress sensorAddresses[37] = {
  { 0x28, 0xFF, 0x64, 0x0E, 0x6D, 0x99, 0xF0, 0xE3 },
  { 0x28, 0xFF, 0x64, 0x0E, 0x6D, 0x87, 0x9C, 0x15 },
  { 0x28, 0xFF, 0x64, 0x0E, 0x6C, 0x64, 0x6C, 0xEA },
  { 0x28, 0xFF, 0x64, 0x0E, 0x7B, 0x2A, 0x06, 0x86 },
  { 0x28, 0xFF, 0x64, 0x0E, 0x7B, 0x13, 0x6A, 0xDF },
  { 0x28, 0xFF, 0x64, 0x0E, 0x7E, 0x14, 0xA8, 0xF2 },
  { 0x28, 0xFF, 0x64, 0x0E, 0x7B, 0x13, 0x0A, 0xBA },
  { 0x28, 0xFF, 0x64, 0x0E, 0x6D, 0xA5, 0x0B, 0xD7 },
  { 0x28, 0xFF, 0x64, 0x0E, 0x7E, 0x3F, 0xA5, 0xED },
  { 0x28, 0xFF, 0x64, 0x0E, 0x7E, 0x6F, 0xF5, 0x41 },
  { 0x28, 0xFF, 0x64, 0x0E, 0x6C, 0x7C, 0x02, 0x0A },
  { 0x28, 0xFF, 0x64, 0x0E, 0x7E, 0x0B, 0x3C, 0x76 },
  { 0x28, 0xFF, 0x64, 0x0E, 0x7B, 0xEE, 0xD7, 0x00 },
  { 0x28, 0xFF, 0x64, 0x0E, 0x7E, 0x3E, 0x9E, 0xB7 },
  { 0x28, 0xFF, 0x64, 0x0E, 0x79, 0x65, 0x93, 0x64 },
  { 0x28, 0xFF, 0x64, 0x0E, 0x7B, 0x2D, 0x19, 0x34 }, 
  { 0x28, 0xFF, 0x64, 0x0E, 0x7B, 0xE8, 0x17, 0x60 },
  { 0x28, 0xFF, 0x64, 0x0E, 0x6D, 0xB8, 0xB9, 0x3C },
  { 0x28, 0xFF, 0x64, 0x0E, 0x6C, 0x78, 0xE1, 0x3A },
  { 0x28, 0xFF, 0x64, 0x0E, 0x6D, 0xAE, 0xF2, 0x1C },
  { 0x28, 0xFF, 0x64, 0x0E, 0x7E, 0x76, 0xDD, 0xFE },
  { 0x28, 0xFF, 0x64, 0x0E, 0x7E, 0x74, 0x5F, 0x5F },
  { 0x28, 0xFF, 0x64, 0x0E, 0x7B, 0x28, 0x79, 0xAE },
  { 0x28, 0xFF, 0x64, 0x0E, 0x62, 0x0C, 0xA6, 0x86 },
  { 0x28, 0xFF, 0x64, 0x0E, 0x6C, 0x7D, 0x32, 0x70 },
  { 0x28, 0xFF, 0x64, 0x0E, 0x6D, 0x57, 0x63, 0x78 },
  { 0x28, 0xFF, 0x64, 0x0E, 0x6D, 0x99, 0x53, 0xAE },
  { 0x28, 0xFF, 0x64, 0x0E, 0x6C, 0x7C, 0x68, 0x11 },
  { 0x28, 0xFF, 0x64, 0x0E, 0x7E, 0x6E, 0x41, 0xD6 },
  { 0x28, 0xFF, 0x64, 0x0E, 0x6D, 0xAA, 0xF7, 0x18 },
  { 0x28, 0xFF, 0x64, 0x0E, 0x6D, 0xBA, 0x4A, 0x3B },
  { 0x28, 0xFF, 0x64, 0x0E, 0x7E, 0x21, 0xCB, 0xA7 },
  { 0x28, 0xFF, 0x64, 0x0E, 0x62, 0x47, 0xB6, 0xA3 },
  { 0x28, 0xFF, 0x64, 0x0E, 0x6D, 0xA4, 0x5C, 0x4B },
  { 0x28, 0xFF, 0x64, 0x0E, 0x7E, 0x21, 0x0A, 0x33 },
  { 0x28, 0xFF, 0x64, 0x0E, 0x62, 0x4B, 0x57, 0x59 },
  { 0x28, 0xFF, 0x64, 0x0E, 0x6D, 0x87, 0xF1, 0x8D },
 }; 

// Prototipos de funciones
void setupSD();
void logData();
void setAlarm();

void setup() {
  Serial.begin(115200);

  Wire.begin(SDA_PIN, SCL_PIN);
  if (!rtc.begin()) {
    Serial.println("Error inicializando RTC.");
    while (1);
  }
  if (rtc.lostPower()) {
    rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
  }

  setAlarm();

  pinMode(WAKE_PIN, INPUT_PULLUP);
  esp_sleep_enable_ext0_wakeup(WAKE_PIN, LOW);

  sensors.begin();
  setupSD();
}

void loop() {
  logData();
  Serial.println("Entrando en DeepSleep...");
  delay(100);
  esp_deep_sleep_start();
}

void setupSD() {
  SPI.begin(SCK, MISO, MOSI, CS);

  if (!SD.begin(CS)) {
    Serial.println("Error inicializando la tarjeta SD.");
    while (1);
  }
  Serial.println("Tarjeta SD inicializada correctamente.");
}

void logData() {
  // Obtener tiempo actual del RTC
  DateTime now = rtc.now();

  // Solicitar temperaturas a los sensores
  sensors.requestTemperatures();
  float temperatures[NUM_SENSORS];
  for (int i = 0; i < NUM_SENSORS; i++) {
    temperatures[i] = sensors.getTempCByIndex(i);
  }

  // Crear o abrir el archivo CSV
  bool fileExists = SD.exists("/datalog.csv");
  dataFile = SD.open("/datalog.csv", FILE_APPEND);
  if (!dataFile) {
    Serial.println("Error abriendo el archivo en la SD.");
    return;
  }

  // Escribir encabezados si el archivo no existe
  if (!fileExists) {
    dataFile.println("Año,Mes,Día,Hora,Minuto,Segundo,Nodo,Profundidad (cm),Temperatura (°C)");
  }

  // Escribir datos en el archivo
  for (int i = 0; i < NUM_SENSORS; i++) {
    int depth = (i < TRANSITION_SENSOR) 
                ? (i * DISTANCE_SHORT_CM) 
                : ((i - TRANSITION_SENSOR) * DISTANCE_LONG_CM + (TRANSITION_SENSOR - 1) * DISTANCE_SHORT_CM);

    dataFile.printf(
      "%04d,%02d,%02d,%02d,%02d,%02d,%d,%d,%.2f\n",
      now.year(), now.month(), now.day(), now.hour(), now.minute(), now.second(),
      NODE_NUMBER, depth, temperatures[i]);
  }

  dataFile.close();
  Serial.println("Datos guardados en la tarjeta SD.");
}

void setAlarm() {
  rtc.disableAlarm(1);
  rtc.clearAlarm(1);
  rtc.clearAlarm(2);
  rtc.writeSqwPinMode(DS3231_OFF);
  rtc.setAlarm1(
    rtc.now() + TimeSpan(0, 0, 1, 0), 
    DS3231_A1_Minute
  );
}
